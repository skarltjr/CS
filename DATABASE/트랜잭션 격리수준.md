### 트랜잭션 격리 수준

#### isolation level
```
트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준
레벨이 높아질수록 더욱 격리시킨다
```

#### isolation level의 필요성
```
데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록한다.
따라서 locking을 통해 트랜잭션이 db를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는것이 필요
그러나 무조건 locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현한다며 db성능이 매우 저하

그렇다고 locking 범위를 줄이면 잘못된 값이 처리되는 문제가 발생할 수 있다.
-> 최고 효율의 locking방법이 필요
```

### isolation level의 종류
#### Read Uncommitted / 레벨 0
```
select 문장이 수행되는 동안 데이터에 shared lock이 걸리지 않느 계층
즉 트랜잭션에서 처리중이거나 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽는것을 허용

사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다

문제점
-> 데이터베이스의 일관성을 유지하는것이 불가능
-> 말그대로 제대로 처리되지않은 데이터를 읽어갈 수 있다.
Dirty Read 발생
```

#### Read Committed / 레벨 1
- <img width="462" alt="스크린샷 2022-03-22 오후 9 16 06" src="https://user-images.githubusercontent.com/62214428/159479929-a562d568-133c-4404-92a8-18908e178656.png">

```
Commit이 이루어진 데이터만 조회 가능
★SQL 서버가 Default로 사용하는 Isolation Level
실제 데이터가 아닌 Undo영역의 백업된 데이터를 읽는다

--- 
문제 : 
Non-Repeatable Read 발생 가능
트랜잭션-1이 Commit한 이후 아직 끝나지 않는 트랜잭션-2가 다시 테이블 값을 읽으면 값이 변경
```

#### Repeatable Read / 레벨2
```
트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
트랜잭션이 시작되고 종료되기 전까지 한 번 조회한 값은 계속 같은 값이 조회되는 격리 수준이다.
즉 대상이 되는 데이터에 대해 쓰는동안 읽을 수 없고 읽는 동안 쓸 수 없다.
그러나 데이터 추가는 가능하기에 phantomRead는 발생

트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장
다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능

```
#### Serializable / 레벨3
```
완벽한 읽기 일관성 모드르 제공
다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능
```

```
정리
READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.
READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다.
REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.
SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.(성능 매우 떨어짐)
```
#### 고려사항
```
결국 트랜잭션의 격리수준은 동시성 & 데이터 무결성과 밀접한 관계

-> 동시성 증가 = 데이터 무결성 저하
-> 데이터 무결성 보장 = 동시성 저하

최적의 중간점을 찾아야한다.
```
```
낮은 단계 Isolation Level을 활용할 때 발생하는 현상들

1.Dirty Read 
커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우

2.Non-Repeatable Read
한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

3. Phantom Read
한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임
```

<img width="417" alt="스크린샷 2022-03-21 오후 1 54 54" src="https://user-images.githubusercontent.com/62214428/159207250-bef7e808-5c92-4b84-8406-3dbb4064745d.png">

