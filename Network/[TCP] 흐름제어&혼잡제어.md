### [TCP] 흐름제어&혼잡제어
#### 1. TCP란
```
- 신뢰성이 보장된 네트워크 통신 방식
```
#### 2. 신뢰성 보장 통신에서 마주칠 수 있는 문제
```
1. 손실 : packet이 전달되는 도중 사라지는 문제
2. 순서 변화 : 순서대로 전달되어야 할 packet의 순서가 뒤바뀌는 문제
3. Congestion : 네트워크가 혼잡
4. Overload : receiver가 감당해야할 데이터가 너무 많은 경우
   - 받는쪽이 처리해야할게 쌓였는데 보내는쪽이 계속 보내면 안된다.
```

#### 3. 흐름제어 및 혼잡제어란?
```
1. 흐름제어
- 앞에서 말한 Overload문제로 
- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 방법
- Flow Control은 receiver가 받는 packet의 양을 조절하는것
- 기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback

2. 혼잡제어
- 네트워크가 혼잡한 상태를 해결하기 위해 데이터 전송 속도를 조절
```

#### 4. 흐름제어 과정
- 송신(sender)측에서 데이터 처리 속도가 송신측(receiver)의 데이터 처리 속도보다 빠를 때 문제가 발생한다.
- 수신측에서 제한된 저장용량을 초과하면 이 후 전달되는 데이터는 손실된다.
- 데이터 손실은 재전송으로 이어지고 이는 곧 네트워크 혼잡으로 이어질 수 있다.
- 이를 위해 송신측의 데이터 전송량을 수신측의 상태에 따라 조절할필요가 있다.
- 해결 방법 :
  - 1. Stop and Wait : 매번 전송한 패킷에 대해 응답을 받아야만 그 다음 패킷을 전송하는 방법
  - <img width="256" alt="스크린샷 2022-03-06 오전 11 19 52" src="https://user-images.githubusercontent.com/62214428/156906396-f6895151-0b44-4557-8f6b-65c05c7b591b.png">
  - 2. Sliding window
    - 수신측에서 설정한 위도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게하여 데이터 흐름을 동적으로 조절
    - 목적 : 전송은 되었지만 ack을 받지 못한 byte의 숫자를 파악하기 위해 사용하는 protocol
    - LastByteSent - LastByteAcked <= ReceivecWindowAdvertised
    - (마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간)
  - Sliding window의 동작방식 : 먼저 윈도우에 포함되는 모든!! 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로(ack) 이 윈도우를 옆으로 옮김으로써 다음 패킷 전송
  - <img width="599" alt="스크린샷 2022-03-06 오전 11 27 22" src="https://user-images.githubusercontent.com/62214428/156906549-0dcc7c9b-5894-41b3-b7b2-a1b24aa441fc.png">
  - 2번에 대한 응답이 왔다는것은 3번전까지 잘 받았다는것 / 그러니까 3번부터 보내줘~
  - ★위 그림에서 ack 3은 받았지만(즉 3번전까지는 받았다는걸 확인받은) 만약 마지막에 ack 6을 못받았다면(= 3번부터 6번전까지 못받았다) 
  - Go Back N!!! => 못받은 3번부터 싹 다 다시보내!!!!

  - 3. Selective Repeat
  - 바로 위 Go back N에서는 (0,1,2)까진 받았고 (3,4,5,6 중) 하나라도 받지 못했다면 3번부터 싹 다 다시보낸다.
  - SR은 이와 약간 다르게 (3,4,5,6 중 5번만 못받은 상황)에서 5번만 다시요청 < - >Go Back N은 이때도 3번부터 싹다 다시보낸다 
  - Window : TCP/IP를 사용하는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 '3 way handshaking'을 통해 수신 호스트의 receive window size에 자신의 send window size를 맞추게 된다.


#### 혼잡제어 과정
- 송신측의 데이터는 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 라우터는 자신에게 온 모든 데이터를 처리할 수없다. 이런 경우 데이터 손실이 발생하고 수신측은 다시 데이터를 전송한다.
- 이는 곧 빈번한 데이터 전송으로 이어지고 네트워크 전체에 혼잡으로 이어질 수 있다.
- ★따라서 수신측은 네트워크 혼잡 상태를 스스로 파악하며 이러한 네트워크 혼잡을 방지하기 위해 송신측에서 데이터 전송 속도를 조절하는데 이를 혼잡제어라고 한다.
- 해결 방법
  - <img width="624" alt="스크린샷 2022-03-06 오후 12 05 41" src="https://user-images.githubusercontent.com/62214428/156907457-190159c8-eb68-43bc-b882-8b6c3f01dfaa.png">
  - AIMD (additive increase / multiplicative decrease)
    - 처음에 패킷을 하나씩보내고 문제없이 잘 도착하면 window크기를 1씩 증가시키면서 전송한다 / additive increase
    - ex. 만약 내가 4개의 window만큼 보냈는데 응답이 잘 도착하면 이건 네트워크 상태가 괜찮다고 판단할 수 있다.
    - 여기서 만약 4개를 보냈을 때 응답을 제대로 받지 못하면 현재 네트워크 상태가 좋지 않기 때문에 혼잡을 방지하고자 과감하게 window size를 절반으로 줄여나간다.
    - 이 후 2개를 보냈을 때 잘 응답을 받으면 다시 1개씩 사이즈를 늘려나간다. 
    - 이 방법의 단점은 초기에 하나의 패킷으로 시작하기에 네트워크를 효율적으로 사용하지 못할 수 있다.
  - Slow Start
    - AIMD방식의 단점인 처음 전송 속도를 올리는데 시간이 오래걸리는점을 보완.
    - 마찬가지로 하나의 패킷 전송으로 시작하되 문제없다면 window size를 2배씩 증가시킨다.
    - 다만 ★ 이 경우 문제가 발생하면 window size를 아예 1로 감소시켜버린다.
    - 이 후 한 번 문제가 생겼을 때 ex. window size를 8로 했을 때 문제가 생겼다는걸 파악한 후 window size를 1로 감소시킨 후 문제가 발생한 window size의 절반인 4까지는 빠르게 증가시키고 이 후부터는 조심스럽게 1씩 증가시킨다.






