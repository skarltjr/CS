```
많이 들어봤지만 누군가 설명을 해달라고 했을 때 제대로 설명할 수 있을까?...
제대로 알고가고자 정리한다.
```

### 개요
```
만약 객체라는 개념이 없다고 생각해보자


우리가 N명의 플레이어에 대해 정의하려면 아래처럼 반복적인 코드를 작성해야한다
const playerOne = {
  name: "player1",
  age : 23,
  skill : "eating"
}

const playerTwo = {
  name: "player2",
  age : 43,
  skilll : "moving"
}

const playerThree = {
  name: "player3",
  age : 63,
  skill : "crying"
}

문제점 : 
1. 공통 부분이 존재함에도 매 번 동일한 코드를 작성해야한다
2. 이에따라 중복된 코드가 많이 발생한다
3. 빈번한 코드 올 발생 가능 : playerTwo의 skill을 봐보자. 그냥 지나쳤겠지만 철자가 다르다

이러한 문제로부터 파생된것이 객체지향 프로그래밍
```

### ⭐️객체 지향 프로그래밍
```
객체란 속성(상태)과 기능(동작)을 가진 덩어리

즉 공통적으로 필요한 속성(필드) & 기능(매서드)의 집합체를 구성함으로써 반복을 줄이며 
기능을 각기 달리 구현함으로써 독립성을 확보

그리고 이러한 객체들간의 협업을 통해 하나의 프로그램을 만들어내는것이 객체지향 프로그래밍
```

### 객체 지향 프로그래밍의 특징
- 추상화
```
추상화란 필요로 하는 속성이나 행동을 추출하는것

사물들의 공통 부분을 정의하고 개별적인 사물들은 이를 바탕으로 자신만의 구현을 함으로써 
중복은 줄이고 유연함을 가져갈 수 있다.

만약 개,고양이,사자외에 호랑이라는 "동물"이 추가돼야할 때 
호랑이는 "동물"이 갖는 공통 특성을 추상화에 정의된 내용을 바탕으로 호랑이만의 방식으로 필요한 부분을 구체화하거나 추가함으로써 유연하게 동작할 수 있다.
```
- 캡슐화
```
캡슐화란 a의 변화가 b에 주는 영향력을 최소화하는것
즉 낮은 결합도를 유지할 수 있도록 설계하는 것

-> a가 b의 내용을 몰라서 a가 b의 내용을 건드리지 못할 때 결합도를 낮출 수 있다.
-> 즉 접근 제어를 통한 정보 은닉으로 캡슐화를 실현한다
```
- 상속
```
부모 클래스의 특성을 물려받아 자식을 구현함으로써 
재사용성을 증진시키며 기능의 확장을 도모할 수 있다

단 부모 클래스의 변경이 어려워지며 잘못된 상속 사용이 발생할 수 있다

```
- 다형성
```
개인적으로 객체 지향에서 가장 좋아하는 부분이다
마치 사람마다의 개성이 있듯이 사물,객체마다의 개성을 부여하는것이라고 생각하며 
이것이 현실세계를 모방한 프로그래밍인 객체지향의 가장 주요포인트라고 생각한다.

부모 클래스나 인터페이스의 기능을 자신만의 방법으로 구현(오버로딩,오버라이딩)함으로써 객체만의 개성을 갖는 것
또한 이를 통해 유연함을 갖는다
```

### 좋은 객체 지향 설계 5원칙 - SOLID
1. S - single responsibility / 단일 책임 원칙
```
클래스는 하나의 책임을 가져야한다.
이를 통해 하나의 클래스 수정으로 인한 영향력을 최소화한다
```
2. O - open closed principle
```
확장에는 열려있고 수정에는 닫혀있어야한다
즉 기존 코드의 수정없이 기능을 수정하거나 추가할 수 있어야한다.
```
3. L - 리스코프 치환 법칙
```
상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
```
4. I - 인터페이스 분리 법칙
```
클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들기 위해 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 
```
5. D - DIP / 의존관계 역전
```
고수준 모듈은 저수준 모듈 구현에 의존하지 않는다.
즉 프로그래머는 구체화가아닌 추상화에 의존해야한다.

이를 통해 구체적인 저수준 모듈이 수정되어도 고수준 모듈은 변경할 필요가 없다


실제로 프로젝트에서 IOC를 통한 DIP를 실현
- Repository가 구체적인 JPARepository에 의존하는 경우 구체적인 구현체에 따라 상위모듈인 repository가 변경되어야한다
- 그러나 제 3자(adapter)에게 어떠한 ex)orm의 기능을 사용할지에 대한 책임을 위임함으로써
- 고수준 모듈인 repository인터페이스는 필요한 기능만을 정의하며 
- 그 기능을 어떠한 방식으로 구현할지 adapter가 결정하여 고수준 모듈은 고수준 모듈에 의존하며 
- 기존과는 다르게 저수준 모듈인 jparepository가 상위 고수준 모듈인 adapter에게 의존하도록변경
- 이를 통해 우리는 추상화에 의존하며 추상화된 기능은 그 구현 방식이 변하더라도 기존에 정의된 코드는 변경되지 않는다
```
