### 3. 정렬 알고리즘별 시간복잡도 & 공간복잡도
- <img width="799" alt="스크린샷 2022-07-02 오후 5 57 27" src="https://user-images.githubusercontent.com/62214428/176993886-ef28281b-7fc9-4a2a-906d-b120ced1f3cf.png">


#### 1. 선택 정렬
- <img width="437" alt="스크린샷 2022-07-02 오후 5 48 29" src="https://user-images.githubusercontent.com/62214428/176993641-aa593dd6-321f-412d-8c88-b936fdf1d0e3.png">

```
- 0번부터 다른애들이랑 전부 비교해서 가장 작은 값을 찾아 그 자리에 배치한다
시간복잡도 : O(n^2) = 이중 반복문
공간복잡도 : O(1) = 단 하나의 추가 변수만 필요
```

#### 2. 버블 정렬
- <img width="414" alt="스크린샷 2022-07-02 오후 6 04 38" src="https://user-images.githubusercontent.com/62214428/176994095-2e9922b6-4685-4ae2-9953-95986c9ca5c3.png">
```
- 가장 큰 놈을 뒤로 보낸다
시간복잡도 : O(n^2) = 이중반복문
공간복잡도 : O(1) = 단 하나의 추가 변수 필요
```

#### 3. 삽입 정렬
- <img width="451" alt="스크린샷 2022-07-02 오후 6 33 55" src="https://user-images.githubusercontent.com/62214428/176995040-17beb415-1cd3-4182-b99b-06c94a4a898f.png">

```
1번부터 자기 자신 왼쪽에 있는애들 둘러보면서 나보다 크면 오른쪽으로 한 칸씩 밀어버린다.

시간복잡도 : O(n^2)
공간복잡도 : O(1)
```
#### 4. 병합 정렬
```
시간복잡도 : O(N logN)
공간복잡도 : O(N) = 정렬을위한 똑같은 크기의 배열 하나 더 필요

public class Main {
    static int[] ans;
    public static void main(String[] args) throws IOException {
        int[] arr = {3, 1, 5, 9, 7};
        ans = new int[arr.length];
        mergeSort(arr,0,arr.length-1);

        for (int i = 0; i < ans.length; i++) {
            System.out.print(ans[i] + " ");
        }
    }

    private static void mergeSort(int[] arr,int start, int end) {
        if (start < end) {
            int mid = (start + end) / 2;
            mergeSort(arr, start, mid);
            mergeSort(arr, mid + 1, end);
            merge(arr, start, mid, end);
        }
    }

    private static void merge(int[] arr, int start, int mid, int end) {
        int left = start;
        int right = mid+1;
        int index = left;

        while (left <= mid && right <= end) {
            if (arr[left] < arr[right]) {
                ans[index] = arr[left];
                index++;
                left++;
            } else {
                ans[index] = arr[right];
                index++;
                right++;
            }
        }

        while (left <= mid) {
            ans[index] = arr[left];
            left++;
            index++;
        }
        while (right <= end) {
            ans[index] = arr[right];
            right++;
            index++;
        }

        for (int i = start; i <= end; i++) {
            arr[i] = ans[i];
        }
    }
}

```
