## 3. 리스트
```
자바의 배열은 개념적인 배열과 "동일"했었나?
- 아니다 / 자바의 배열은 immutable 오히려 arrayList가 개념적인 배열과 더욱 비슷하다

마찬가지로 list또한 그렇다
개념적인 list와 자바의 list 구현체는 약간의 차이가 있다
- vector
- arrayList
- LinkedList
```

### list 구현체
```
기본적으로 모두 mutable

1. vector & arrayList VS linkedList
- vector & arrayList는 배열을 활용한다
- 앞서 말했듯이 arrayList는 사실상 개념적인 배열과 가장 유사하며 이들은 배열을 이용하고 이 배열은 mutable 
- 그리고 배열을 활용하면서 mutable하기 위해 더 큰 새로운 배열을 하나 더 만들고 기존 배열을 복사
- 배열을 활용하기 때문에 조회 O(1) / 삽입 삭제 O(N)
- 그러나 contains(a)의 경우 돌아다니면서 a 값을 갖고 있는 애를 찾아야하기때문에 조회지만 O(N)
- 외우지말고 이해를해라

2. vector VS arrayList
- vector는 synchronization이 적용
- ⭐️즉 모든 vector의 매서드는 한 번에 한 스레드만 접근가능
- 새로 알게된 사실인만큼 잘 기억하자. 그리고 synchronization이 적용된다는건 분명 오버헤드가 존재
- 따라서 판단 후 사용하자

3. linkedList
- 개념적 list와 가장 유사
- 연결된 노드의 상호작용
- 따라서 조회 O(N) / 삽입 삭제 = O(1) / 그러나 삽입 삭제를 할 위치를 찾을 때 최대 O(N)
```
```
참고 : 
List<Integer> list = new ArrayList<>();

기본적으로 arrayList를 생성할 때 디폴트로 사이즈가 10이다
즉 10개까지는 list에 원소를 추가하더라도 시간복잡도가 O(1) 왜? 이미 그만한 크기가 보장되어있어서 추가 배열 생성 후 복사 필요x
```
