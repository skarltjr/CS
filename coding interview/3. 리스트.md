## 3. 리스트
```
자바의 배열은 개념적인 배열과 "동일"했었나?
- 아니다 / 자바의 배열은 immutable 오히려 arrayList가 개념적인 배열과 더욱 비슷하다

마찬가지로 list또한 그렇다
개념적인 list와 자바의 list 구현체는 약간의 차이가 있다
- vector
- arrayList
- LinkedList
```

### list 구현체
```
기본적으로 모두 mutable

1. vector & arrayList VS linkedList
- vector & arrayList는 배열을 활용한다
- 앞서 말했듯이 arrayList는 사실상 개념적인 배열과 가장 유사하며 이들은 배열을 이용하고 이 배열은 mutable 
- 그리고 배열을 활용하면서 mutable하기 위해 더 큰 새로운 배열을 하나 더 만들고 기존 배열을 복사
- 배열을 활용하기 때문에 조회 O(1) / 삽입 삭제 O(N)
- 그러나 contains(a)의 경우 돌아다니면서 a 값을 갖고 있는 애를 찾아야하기때문에 조회지만 O(N)
- 외우지말고 이해를해라

2. vector VS arrayList
- vector는 synchronization이 적용
- ⭐️즉 모든 vector의 매서드는 한 번에 한 스레드만 접근가능
- 새로 알게된 사실인만큼 잘 기억하자. 그리고 synchronization이 적용된다는건 분명 오버헤드가 존재
- 따라서 판단 후 사용하자

3. linkedList
- 개념적 list와 가장 유사
- 연결된 노드의 상호작용
- 따라서 조회 O(N) / 삽입 삭제 = O(1) / 그러나 삽입 삭제를 할 위치를 찾을 때 최대 O(N)
```
```
참고 : 
List<Integer> list = new ArrayList<>();

기본적으로 arrayList를 생성할 때 디폴트로 사이즈가 10이다
즉 10개까지는 list에 원소를 추가하더라도 시간복잡도가 O(1) 왜? 이미 그만한 크기가 보장되어있어서 추가 배열 생성 후 복사 필요x
```

### ps 1
```
단일 연결 리스트를 뒤집는 함수를 구현하라.
예) 1 -> 2 -> 3   =>  3 -> 2 -> 1
```
```
⭐️순회방식의 뒤집기

시간복잡도 : O(N)
공간복잡도 : O(1)
private static void reverse(Node node) {
    Node prev = null;
    Node next = null;
    Node current = node;

    while (current != null) {
        next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
}


----
1 -> 2 -> 3
Node third = new Node(null, null, 3);
Node second = new Node(null, third, 2);
Node first = new Node(null, second, 1);

Node node = first;
reverse(node);
3 -> 2 -> 1




⭐️재귀방식의 뒤집기
시간복잡도 : O(N)
공간복잡도 : O(N) / stack
-----

private static void reverse(Node node) {
    if (node == null || node.next == null) {
        return;
    }
    reverse(node.next);
    node.next.next = node;
    node.next = null;
}

설명 : 

/*
* 재귀의 핵심은 문제를 줄여나가는것
* */
private static void reverse(Node node) {
    if (node == null || node.next == null) {
        return;
    }
    /**
     * 1 -> 2 -> 3
     *    | 2 -> 3
     *        |  3
     * 처럼 문제의 범위를 줄여나간다
     * 그럼 3은 node.next == null이니 return
     * 그럼 2는 reverse() 이후 2.next.next = 2 즉 3.next=2를설정
     * 그럼 1은 reverse() 이후 1.next.next = 1 즉 2.next=1를 설정
     * */
    reverse(node.next);


    node.next.next = node;
    node.next = null;
}

```
