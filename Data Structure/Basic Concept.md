### ⭐️ Array & Linked list
#### Array
- `메모리상에 연속적으로 데이터를 저장`하는 자료구조
  - 메모리상에 연속적으로 저장하기 때문에 cache locality가 뛰어나서 cache hit 가능성이 크다
- `탐색 O(1)` : 인덱스를 사용해 `random access`가능
- `삽입/삭제  O(N)` : 삽입/삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해야한다.
- `크기 불변`: Immutable

#### Linked List
- `메모리가 불연속적`으로 배치된 자료구조
- 다음 노드를 가리키는 주소인 포인터를 통해 접근하는 자료구조
  - 자료의 주소 값으로 연결된 형태
- `탐색 O(N)` : 데이터 검색시 처음 노드부터 순차 접근
- `삽입/삭제 O(N)` : 주소의 연결만 변경하면 된다 -> But, 삽입/삭제할 노드를 찾는데 O(N)필요
```
비교
- 삽입과 삭제가 빈번하다면 Linked List 사용이 효율적
- 데이터 조회가 빈번하다면 Array가 효율적
```
------

### ⭐️ Hash table
#### Hash table이란
- `key - value`로 데이터를 저장하는 자료구조
- key에 `해시 함수`를 적용해 고유한 인덱스를 생성하고, 이 인덱스를 활용해 값을 저장/검색
- 실제 값이 저장되는 장소를 `버킷(슬롯)`이라고한다.
- 배열과 리스트의 장점을 합친 자료구조로 `key값`을 통해 해시주소를 알아내어 평균적으로 탐색이 `O(1)`

#### 해시 함수
- 임의의 길이의 데이터를 수학적 연산을 통해 거종된 길이의 데이터로 매핑하는 함수
- 해시 함수에 얻어지는 값을 해시라고한다.

#### 해시 충돌
- 서로 다른 key가 같은 해시값으로 변경되는것
- 같은 해시값에 대해 데이터를 조회하는 경우 최대 O(N)

#### 해시 충돌 해결법
- 체이닝 : 추가 메모리를 사용해 버킷에 데이터를 연결리스트로 관리
  - 같은 여러 key가 같은 해시를 가지면 그 해시(key) : value에서 value가 여러개 될 수 있으니 연결리스트로
- 개방 주소법 : 기존의 비어있는 버킷의 공간을 활용
  - 선형 조사법 : 현재 버킷의 인덱스에서 고정폭씩 이동하며 데이터를 버킷에 저장
  - 이차 조사법 : 현재 버킷의 인덱스에서 `k^2 (k=1,2,...)`씩 이동하며 데이터를 버킷에 저장
  - 이중 해싱 : 해싱된 값을 한번 더 해싱 -> 연산증가
  - https://j3sung.tistory.com/759
```
정리
- 해시테이블이란 임의의 키가 해시 함수를 거쳐 해시값이 되고 이 해시와 value를 저장

장점 :
- 적은 리소스로 많은 데이터를 효율적으로 관리 가능
- 빠른 검색,삽입,삭제

단점 : 
- 충돌 발생 가능성
- 들어온 순서 무시
```
- 안정 해시 : https://github.com/skarltjr/Memory_Write_Record/issues/61#issuecomment-1028931741
