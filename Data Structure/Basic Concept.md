### ⭐️ Array & Linked list
#### Array
- `메모리상에 연속적으로 데이터를 저장`하는 자료구조
  - 메모리상에 연속적으로 저장하기 때문에 cache locality가 뛰어나서 cache hit 가능성이 크다
- `탐색 O(1)` : 인덱스를 사용해 `random access`가능
- `삽입/삭제  O(N)` : 삽입/삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해야한다.
- `크기 불변`: Immutable

#### Linked List
- `메모리가 불연속적`으로 배치된 자료구조
- 다음 노드를 가리키는 주소인 포인터를 통해 접근하는 자료구조
  - 자료의 주소 값으로 연결된 형태
- `탐색 O(N)` : 데이터 검색시 처음 노드부터 순차 접근
- `삽입/삭제 O(N)` : 주소의 연결만 변경하면 된다 -> But, 삽입/삭제할 노드를 찾는데 O(N)필요
```
비교
- 삽입과 삭제가 빈번하다면 Linked List 사용이 효율적
- 데이터 조회가 빈번하다면 Array가 효율적
```
------

### ⭐️ Hash table
#### Hash table이란
- `key - value`로 데이터를 저장하는 자료구조
- key에 `해시 함수`를 적용해 고유한 인덱스를 생성하고, 이 인덱스를 활용해 값을 저장/검색
- 실제 값이 저장되는 장소를 `버킷(슬롯)`이라고한다.
- 배열과 리스트의 장점을 합친 자료구조로 `key값`을 통해 해시주소를 알아내어 평균적으로 탐색이 `O(1)`

#### 해시 함수
- 임의의 길이의 데이터를 수학적 연산을 통해 거종된 길이의 데이터로 매핑하는 함수
- 해시 함수에 얻어지는 값을 해시라고한다.

#### 해시 충돌
- 서로 다른 key가 같은 해시값으로 변경되는것
- 같은 해시값에 대해 데이터를 조회하는 경우 최대 O(N)

#### 해시 충돌 해결법
- 체이닝 : 추가 메모리를 사용해 버킷에 데이터를 연결리스트로 관리
  - 같은 여러 key가 같은 해시를 가지면 그 해시(key) : value에서 value가 여러개 될 수 있으니 연결리스트로
- 개방 주소법 : 기존의 비어있는 버킷의 공간을 활용
  - 선형 조사법 : 현재 버킷의 인덱스에서 고정폭씩 이동하며 데이터를 버킷에 저장
  - 이차 조사법 : 현재 버킷의 인덱스에서 `k^2 (k=1,2,...)`씩 이동하며 데이터를 버킷에 저장
  - 이중 해싱 : 해싱된 값을 한번 더 해싱 -> 연산증가
  - https://j3sung.tistory.com/759
```
정리
- 해시테이블이란 임의의 키가 해시 함수를 거쳐 해시값이 되고 이 해시와 value를 저장

장점 :
- 적은 리소스로 많은 데이터를 효율적으로 관리 가능
- 빠른 검색,삽입,삭제

단점 : 
- 충돌 발생 가능성
- 들어온 순서 무시
```
- 안정 해시 : https://github.com/skarltjr/Memory_Write_Record/issues/61#issuecomment-1028931741
```
안정 해시는 : 해시 테이블 크기가 조정될 때 평균적으로 k/n개의 키만 재배치하는 기술
여기서 k는 키의 개수 / n은 슬롯(서버)의 개수
```

-----
### ⭐️ Stack & Queue
#### Stack
- `Last in First out / 선입후출` 방식으로 `최근성`에 집중하는 자료구조
- Array로 구현할때 효율적
  - 만약 linked list라면 최신. 즉 마지막을 찾기위해 O(n)이라 비효율적
#### Queue
- `First in First out / 선입선출` 방식으로 '순차성'에 집중하는 자료구조
- Linked List가 효율적

-----

### ⭐️ Tree
- `사이클을 가지지 않는` 그래프 / 비선형 자료구조
- 부모 자식 관계를 갖는 `계층적` 자료구조
- `이진 트리` : 최대 2개의 자식 노드들만 가질 수 있는 트리
- `포화 이진 트리` : 최대 2개의 자식 노드들을 갖고 각 레벨에 노드와 꽉 차있는 트리
- `완전 이진 트리` : 높이가 K인 트리에서 레벨 1~K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리
- `이진 탐색 트리` : 탐색을 위해 만들어진 자료구조로 `각자의 부모 노드!! 키를 기준으로 왼쪽 자식은 모두 부모보다 작으며 오른쪽 자식은 모두 부모보다 큰` 트리
```
순회 방식
1. 중위 순회 : 왼 -> 루트 -> 오른
2. 전위 순회 : 루트 -> 왼 -> 오른
3. 후위 순회 : 왼 -> 오른 -> 루트
```
### ⭐️ 이진 탐색 트리
```
1. 노드의 왼쪽자식들은 각자의 부모의 키값보다 모두 작으며 오른쪽 노드는 각자의 부모 노드보다 큰 값을 가지는 트리
2. 중복 값을 가지지 않는다
3. 이진 탐색과 연결리스트의 장점을 결합한 트리
4. 삽입 시 중위 순회를 통해 위치를 찾아간다.

이진탐색 : 탐색에 소요되는 시간복잡도는 O(logN), but 삽입,삭제가 불가능
연결리스트 : 삽입, 삭제의 시간복잡도는 O(1), but 탐색하는 시간복잡도가 O(N)

-> 이진 탐색트리
균등 트리 : 노드 개수가 N개일 때 O(logN)
편향 트리 : 노드 개수가 N개일 때 O(N)
```
- 편향을 피하는 방법 : 자가 균형 트리
```
1. Avl tree : 왼쪽과 오른쪽 자식의 높이 차이가 1이하일것을 요구
  - 삭제/추가시 재정렬을 통해 높이 유지 / 레드 블랙트리보다 엄격
  
2. red black tree : 모든 노드가 빨강 또는 검정의 색을 갖는 트리로 루트부터 리프까지의 최장 경로는 최단 경로의 두 배 이상이 될 수 없음
  - 삭제/추가 시에 재정렬과 색깔 재배치를 통해 규칙을 유지
```
### 이진 탐색 트리 삽입
- 4르 추가한다고 생각해보자
- <img width="375" alt="스크린샷 2022-03-27 오후 4 15 32" src="https://user-images.githubusercontent.com/62214428/160270991-620c3776-3d1c-4d18-98a0-06dd487e2e42.png">

### 이진 탐색 트리 삭제
1. 자식이 없는 경우 : 바로 삭제
2. 자식이 하나만 있는 경우 : 삭제하고 자신의 부모와 자신의 자식을 연결
  - 자신이 부모의 왼쪽 자식이면 자신의 자식은 무조건 부모보다 작으니. 반대도 마찬가지
  - <img width="565" alt="스크린샷 2022-03-27 오후 4 19 08" src="https://user-images.githubusercontent.com/62214428/160271058-8391457a-23fa-43cb-8048-462a3f56c840.png">
3. 자식이 둘있는 경우 : 
- <img width="611" alt="스크린샷 2022-03-27 오후 4 22 36" src="https://user-images.githubusercontent.com/62214428/160271170-f630259a-b0eb-4852-8eb4-c57cbaf953dd.png">

```
1. 삭제 대상 노드의 오른쪽 서브트리를 찾는다(오른쪽은 본인보다 전부 크다).
2. 오른쪽 서브트리에서 최소값을 찾는다.
3. 2에서 찾은 최소값을 삭제 대상 노드에 복사한다.
4. 최소값 노드를 삭제한다.
```


### ⭐️ Heap
- 힙은 `완전 이진 트리`의 일종으로 `우선 순위 큐`를 구현하기 위해 만들어진 자료구조
- 최소 혹은 최대값을 쉽게 찾기 위한 자료구조
- 부모 노드의 키값이 자식 노드의 키값보다 항상 큰/작은 완전 이진 트리

```
재구성

원소 삽입: O(logn)
새로운 노드를 힙의 마지막 노드에 삽입 -> 새로운 노드를 부모 노드들과 교환

원소 삭제: O(logn)
루트 노드 삭제 -> 삭제된 루트에 힙의 마지막 노드를 가져옴 -> 재구성
```
### heap 삽입
```
1. Node중 가장 마지막 Node에 우선 연결
2. swap을 통해 자리 찾는다
```
- <img width="712" alt="스크린샷 2022-03-27 오후 4 26 52" src="https://user-images.githubusercontent.com/62214428/160271368-d578d97c-b2f3-4c5d-9304-91b72f774b85.png">
- <img width="706" alt="스크린샷 2022-03-27 오후 4 28 16" src="https://user-images.githubusercontent.com/62214428/160271376-56db10ac-08ae-415a-a462-df7f4b1247ae.png">
- <img width="696" alt="스크린샷 2022-03-27 오후 4 28 19" src="https://user-images.githubusercontent.com/62214428/160271381-a9b7e557-6319-48af-848e-9df5c4b4b293.png">

### heap 삭제
```
1. 힙은 우선순위 큐를 위한 자료구조로 삭제는 루트(최소,최대값)을 삭제한다.
2. 마지막 노드를 루트자리로 가져온다.
3. swap을 통해 위치를 찾아간다.
```
- <img width="693" alt="스크린샷 2022-03-27 오후 4 30 24" src="https://user-images.githubusercontent.com/62214428/160271527-9a9c9dee-b09a-43c9-bbb4-b87c77982ad2.png">
- <img width="752" alt="스크린샷 2022-03-27 오후 4 30 27" src="https://user-images.githubusercontent.com/62214428/160271528-49db37e4-add2-41dc-87c6-cc1933e5d893.png">
- <img width="747" alt="스크린샷 2022-03-27 오후 4 30 30" src="https://user-images.githubusercontent.com/62214428/160271529-44ce387a-2ec3-42b4-a39b-679c1a710191.png">
- 최대값이라면 두 자식 중 더 큰값과 swap
- <img width="719" alt="스크린샷 2022-03-27 오후 4 31 23" src="https://user-images.githubusercontent.com/62214428/160271534-ae18319e-38e2-4ffd-ba6f-b0dfe024b98a.png">
- <img width="725" alt="스크린샷 2022-03-27 오후 4 31 28" src="https://user-images.githubusercontent.com/62214428/160271542-720c6121-a828-4005-8141-33d56e899f57.png">
- <img width="668" alt="스크린샷 2022-03-27 오후 4 31 26" src="https://user-images.githubusercontent.com/62214428/160271539-9fdaf07e-7d78-4de8-8631-2ff6bf095c35.png">


-----
### ⭐️ Graph
- 정점과 간선으로 이루어진 자료구조
- 양방향 및 무방향 가능
- 사이클 존재 가능

